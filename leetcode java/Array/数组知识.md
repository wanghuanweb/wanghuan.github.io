#### 1.Arrays静态类

Arrays.sort()

#### 2.数组倒置

就是for循环，首尾交换即可

```
public void reverse(int[] nums,int begin,int end) {
    for(;begin <= end;begin++,end--) {
        int temp = nums[begin];
        nums[begin] = nums[end];
        nums[end] = temp;
    }
}
```

#### 3.移除数组元素

删除某元素，用两个指针就行了，i遍历数组，不等于val的时候则给j

```
public class Solution {
    public int removeElement(int[] nums, int val) {
        int len = nums.length,
            i = 0,
            index = 0;

        for(;i < len;i++) {
            if(nums[i] != val) {
                nums[index++] = nums[i];
            }
        }
        return index;
    }
}
```

#### 4.有序数组合并

其实此题需要归并， 但是要节省额外的空间，将nums2合并到nums1，为了防止重复移动，则应该从后向前移动。
从后往前遍历A和B数组，每次把大的数字从A中m+n位置逐步往前放

```
public class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        int len1 = m - 1,
            len2 = n - 1,
            lenTotal = m + n -1;

        while(len1 >= 0 && len2 >= 0) {
            if(nums1[len1] >= nums2[len2]) {
                nums1[lenTotal--] = nums1[len1--];
            } else {
                nums1[lenTotal--] = nums2[len2--];
            }
        }
       //  就是nums2还有剩余的元素
        if(len1 == -1) {
            while(len2 >= 0) {
                nums1[lenTotal--] = nums2[len2--];
            }
        }
    }
}
```

#### 4.寻找数组集合list和是否为某个数

这种题目一般用深度优先搜索

```
public class Solution {
    public List<List<Integer>> result;
    public List<Integer> seq;

    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        result  = new ArrayList<List<Integer>>();
        seq = new ArrayList<Integer>();

        Arrays.sort(candidates);
        findPaths(candidates,target,0,0);

        return result;
    }

    public void findPaths(int[] candidates,int target,int sum,int level) {
        if(target == sum) {
            result.add(new ArrayList<Integer> (seq));
            return;
        }
        if(target < sum) {
            return;
        }

        for(int i = level;i < candidates.length;i++) {
           //  相当于是当前节点压入栈
            seq.add(candidates[i]);
            sum += candidates[i];
            findPaths(candidates,target,sum,i);
           //  没返回值，也就是当前节点不符合，则弹出栈的意思
            seq.remove(seq.size() - 1);
            sum -= candidates[i];
        }
    }
}

```

#### 5.List去重

```
Set<Integer> set = new HashSet<Integer> (list1);
```

#### 6.二维数组和矩阵

矩阵的转置，也就是(i,j)-->(j,i),即左下到右上，leetcode48,54
