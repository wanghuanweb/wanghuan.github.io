#### 1.前端工程化（以软件工程的思想进行开发）的几个阶段

技术选型，开发效率优化--构建优化--css和js模块化--组件化--资源管理--规范化--自动化

1.技术选型：根据项目进行技术选型（库/框架）       ---提高开发效率
2.构建优化：简单构建优化，对代码压缩、优化、资源合并---提高运行效率
3.模块化：js/css模块化开发                   ---提高维护效率
   js模块化方案--AMD/CommonJS/UMD/ES6 Module等
   css模块化方案--开发基本都是在less、sass、stylus等预处理器的import/mixin特性支持下实现的。
4.组件化和资源管理：组件化开发和资源管理                ---提高了开发，维护效率
  光有JS/CSS的模块化还不够，对于UI组件的分治也有着同样迫切的需求
  **组件化开发**
  1.页面上的每个 独立的 可视/可交互区域视为一个组件；
  2.每个组件对应一个工程目录，组件所需的各种资源都在这个目录下就近维护；（html，css，js，tmpl等在同一个目录）
  3.由于组件具有独立性，因此组件与组件之间可以 自由组合；
  4.页面只不过是组件的容器，负责组合组件形成功能完整的界面；
  5.当不需要某个组件，或者想要替换组件时，可以整个目录删除/替换。
  **资源管理**
  --增量下载
  --按需加载，整个页面执行完毕之后，收集资源加载需求，并替换页面的占位符，即可实现资源的 hash 定位
  “智能”静态资源管理--模块化/组件化开发之后，我们最终要解决的，就是模块/组件加载的技术问题。然而前端与客户端GUI软件有一个很大的不同：
  前端应用没有安装过程，其所需程序资源都部署在远程服务器，用户使用浏览器访问不同的页面来加载不同的资源，随着页面访问的增加，渐进式的将整个程序下载到本地运行，“增量下载”是前端在工程上有别于客户端GUI软件的根本原因。
  根据“增量”的原则，我们应该精心规划每个页面的资源加载策略，使得用户无论访问哪个页面都能按需加载页面所需资源，没访问过的无需加载，访问过的可以缓存复用，最终带来流畅的应用体验。
  1.有加载相关的按需加载、延迟加载、预加载、请求合并等策略；
  2.有缓存相关的浏览器缓存利用，缓存更新、缓存共享、非覆盖式发布等方案；
  3.还有复杂的BigRender、BigPipe、Quickling、PageCache等技术。
  **静态资源管理系统**
  静态资源管理系统 = 资源表+资源加载框架
  1.静态资源的更新和缓存：静态资源是非覆盖式的发布，否则文件名一样的覆盖式html和js无法同时上线，会造成访问失败，是文件名+hash值这种非覆盖式的发布。
  2.资源表是一份数据文件（比如JSON），是项目中所有静态资源（主要是JS和CSS）的构建信息记录，通过构建工具扫描项目源码生成，是一种k-v结构的数据，以每个资源的id为key，记录了资源的类别、部署路径、依赖关系、打包合并等内容，比如
  ```
  {
    "a.js": {
        "url": "/static/js/a.5f100fa.js",
        "dep": [ "b.js", "a.css" ]
    },
    "a.css": {
        "url": "/static/css/a.63cf374.css",
        "dep": [ "button.css" ]
    },
    "b.js": {
        "url": "/static/js/b.97193bf.js"
    },
    "button.css": {
        "url": "/static/css/button.de33108.css"
    }
  }
  ```
  而资源加载框架则提供一些资源引用的API，让开发者根据id来引用资源，替代静态的script/link标签来收集、去重、按需加载资源。调用这些接口时，框架通过查表来查找资源的各项信息，并递归查找其依赖的资源的信息，然后我们可以在这个过程中实现各种性能优化算法来“智能”加载资源。

--写的很好的一篇文章
https://github.com/fouber/blog/issues/10
https://github.com/fouber/blog/issues/3
https://github.com/fouber/blog/issues/4
https://juejin.im/entry/58e8b724b123db0c2e30da91

5.规范化：模块化和组件化确定了开发模型，而这些东西的实现就需要规范去落实。（比如我们组，现在所有业务线迁到vue后，项目结构是基本一致的）mya

6.自动化：相同业务结构是否可以直接用系统生成呢。魔方。（我们组其他同学做的）

#### 3.fis

真正从 前端工程化 的角度设计，不单单是一个打包工具。在FIS3中，js，image，html，css等等，不管你是谁，只要是前端相关的资源都是主角。构建流程不单单根据js来，而是分析每一个文件的依赖关系，生成一个资源表‘sourceMap’，资源表记录每一个文件的依赖关系，以及发布前的位置，和发布后的去向。
