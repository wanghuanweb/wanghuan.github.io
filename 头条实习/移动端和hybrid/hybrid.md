#### 1.Hybrid简介

Hybrid App（混合模式移动应用）是指介于web-app、native-app这两者之间的app，兼具“Native App良好用户交互体验的优势”和“Web App跨平台开发的优势”。
概括起来，Hybrid是一种移动端半Native半web的开发模式。
底层功能API均由 [原生容器] 通过某种方式提供，然后业务逻辑由H5页面完成，最后原生容器加载H5，完成整个业务流程。
原生容器 即为webview，在Native App开发中有一个webview组件用于加载HTML文件，Android中是webview，iOS7以下有UIWebview，7以上有了WKWebview。

#### 3.Hybrid核心技术 - JSBridge

客户端内的H5页面是运行在客户端内的Webview中而非系统浏览器，而端内的Webview本质上是客户端的一个组件（iOS中称之为view，Android称之为activity），组件必然归属于客户端的一个线程（iOS可能是主线程，Android是子线程）。客户端的主线程是可以和Webview组件进行数据交互的。

所以，Bridge的实现一般来说有三种解决方案：

A，信号式（Signal）
信号式，顾名思义是通过某种信号来做信息交换。端内的H5页面所有的请求，包括网页请求、资源请求、ajax等，都是需要经过Webview的，而Webview又与客户端主线程可以通信，那么可以在Webview上加入自定义的协议schema，当Webview捕获到约定的协议时通知客户端主线程执行某个操作。即可以完成H5 → 客户端的调用。比如微信的schema是 weixin:// ，支付宝的schema是 alipay:// 。关于schema的知识，后续再展开。
优点： 兼容性好。
缺点： 调用时延会比较高 200ms~400ms。

B，注入式（Inject）
注入式，简单说就是通过JS引擎往window全局挂载方法，供H5调用。比如，平时我们使用的很多的alert，setTimeout这些JS方法，其实并非JavaScript本身提供，而是BOM。以此类推，我们一样是可以将一些自定义的Native方法，通过JS引擎已BOM的形式注入到全局供H5调用。
优点： 调用速度非常快，参照alert。
缺点： 低版本iOS系统不支持，安卓 4.1以下有安全漏洞，另外这种方式在调用的时候会阻塞Webview线程，有引起线程死锁的风险，所以要求编写注入方法的开发者编写时需要更严谨。

C，请求式（Request）
请求式，这种方式基本上很少见。在客户端启动一个小型的服务器，H5需要调用客户端的时候，通过往 127.0.0.1:port/path/ 发送网络请求来实现。
优点： 似乎没有。。。
缺点： 耗电，单工
JSBridge有多种方式可以实现，实现思路也不尽相同，以上是简单介绍一下我了解的几种，更多的实现方式还在探索中。多种实现方式最后本质是在兼容性和性能之间进行取舍，且并没有最优的方案。只有根据自己需要面对的业务形态，选择最适合的方案。

#### 4.IES Hybrid 现状

http://p9.pstatp.com/obj/39f00006bbf0b6ed4a09

**Web方面存在的问题：**

Web方面存在的问题可以拆解成3+1，4个部分，最后一个是黑盒&安全性问题：
1，H5页面
页面部分目前主要还都是走常规的http/https请求。需要在网络请求上耗费一定的时间（网络时延，DNS解析，加载静态资源等），无法解决一些网络劫持问题。
2，数据请求
数据请求部分也都还是常规的http/https ajax异步请求。只能走常规的ajax，无法解决网络劫持问题，无法做动态选路和接口加密。
3，端能力
我们统一的把通过JSBridge提供的跟客户端双向调用的能力称之为端能力。
4，schema调用
这个是一个黑盒的存在，本质上他也属于端能力的一个范畴，但是没走正规途径。正规的端内里调用都需要走JSBridge，在桥接层会先做一次鉴权，如果没有权限则拒绝调用，有权限才会调用客户端执行对应操作并回调，参考微信JSSDK。而schema是可以理解为客户端内的一个路由控制中心，用来统一控制端内页面的跳转。比如 A页面要去B页面，客户端应该是触发一个schema，如Router.go(“myschema://gotoB”)这样来进行跳转。而当我们在网页里打开 “myschema://gotoB” 时，也会被客户端捕获进而触发客户端路由跳转。这种方式是相当于调用到了客户端的底层路由，而绕过了【鉴权环节】，客户端底层路由是不应该直接暴露出来的，暴露出来的话，相当于任何知道schema的网页，都可以随意调用客户端能力，存在安全问题。

**Native方面存在的问题：**
1，鉴权
目前鉴权这块鉴权api是固定的一个地址，多个App混在一起，无法区分App进行鉴权和授权，不利于后续打造整体开放平台。
2，JSBridge和Native业务层耦合
JSBridge桥接技术，桥接层应该是一个通用技术，IES多个客户端共享一套通用基础技术，而不应该各个业务线各自实现一套，重复造轮子。要复用的前提是基础技术要够纯粹，不能夹杂业务代码，比如之前的App里在桥接层，处理JS调用的时候是直接import客户端的一个类或者方法来处理，有时候还会在桥接层做一些业务逻辑判断（判断是否登录，取当前用户userid，打点上报等等），耦合比较严重，无法横向复用。
其他问题：
经过这一年多，IES发展迅速，从最开始的只有内涵段子一款App，到现在的内涵段子，火山小视频，火山直播SDK，抖音短视频，Flipagram，Hypstar（火山国际化版本），TikTok（抖音国际化版本）多个独立App，每个App需要最少开发iOS和Android两端，还需要考虑一些国际化方面的方案，如果每个App都单独做一套Hybrid方案，开发需要耗费大量的客户端开发资源，做重复造轮子工作。前端也没有办法一套H5页面代码运行在多个客户端，经常需要写很多的if…else…做兼容。各个客户端的文档也不尽相同，有的可能还不完善。再加上一些历史原因，一些比较老的业务线和比较老版本的App，JSBridge的实现和API定义也都比较随意，没有严格遵守的设计和实现规范，有时候都是因为在仓促着急的情况下，为了满足需求，快速怼出来，后续版本迭代&人员更替，一些接口经常没人维护也无法维护，经常是原有接口不管，单独重新开一个接口或者接口加一个type，客户端实现加个if…else…做判断来兼容。这个情况实在是不够优雅，对整体客户端的稳定性和前端开发的效率都不够友好。
综上，我们可以得出的结论是，我们IES目前的Hybrid现状还不够强力，或者说只是做到了提供端能力，还不能称之为方案，与业内大公司的差距还有很大，我们把目前的现在称之为Hybrid 1.0。

#### 5.Falcon: IES Hybrid解决方案

Falcon是一套极速&稳定的Hybrid 2.0解决方案，我们主要做了以下几个事情：

**架构解耦**

前面我们提到了一个耦合的问题，就是之前JSBridge的处理都是在桥接层，直接引入的业务代码实现，相当于是引用式实现。单个App这么实现问题不多，但是遇到我们这种多产品线的情况就不太合适了，引用式的代码耦合太严重，桥接层无法横向复用，其他App无法直接接入。

http://p9.pstatp.com/obj/39f00006bbf0b6ed4a09

我们做的第一件事，是把引用式JSBridge实现改成注册式的实现。简单说，就是我们希望桥接层做做纯粹的桥接的功能，联通H5和Native而不耦合业务逻辑，因此，我们在桥接层和Webview封装在一起，封装成IESWebview，并设计了一个注册机制，做一个注册器，Native端只需要接入IESWebview，并在初始化的时候调用其注册接口，将Native可以支持JSBridge方法注入进去即可。注册表里，其实就是一个Key-Value的Map，key是JSBridge的方法名，value就是客户端对应该JSBridge方法的实现。当H5调用JSBridge时，桥接层即是到注册表中去查找对应的处理方法，如果有则调用，没有即是返回调用失败。

至于注册机制的实现：
* Android端：使用类的继承来实现，定义一个BaseJSBridgeHandler，接入方只需要继承这个基类，实现一个自己的CustomJSBridgeHandler将自己需要支持的JSBridge方法写进去，初始化IESWebview的时候，实例化一个CustomJSBridgeHandler，传递给IESWebview即可。
* iOS端：通过继承IESJSBridge，实现自定义的方法来实现，对UIWebView/WKWebView也做了处理，均会自动集成，无缝切换，业务方可直接使用。

**路由整合**

前面我们提到了客户端schema，schema是客户端的一个路由控制中心，客户端一些重要页面跳转均是基于schema来跳转。而我们的H5页面经常也有需要打开一些客户端的页面且是重要页面（比如：进用户profile页、进直播间、进视频播放页，进详情页等）。之前很多时候，都是代码里直接去唤起某个客户端的view/activity，我们觉得这样实现虽然问题不大，但是不够优雅，因此，所有进入/打开页面的操作，我们都收敛到一个openHotsoon方法中，再以各种type做区分，客户端处理openHotsoon方法是实现，就都是统一的把JSBridge传递的参数，转化成客户端的schema，然后走客户端的统一跳转逻辑。借此，整合H5和客户端路由。

**权限收敛**

前面也提到了一个客户端黑盒般的存在，schema直接调用到客户端路由，存在一定的安全性问题，方案中，我们移除这种直接调用的方式，所有的H5→Native的调用都需要走JSBridge，都需要经过鉴权，鉴权服务器地址也是可以在介入IESWebview的时候进行配置，可以各个业务线各自把控。

http://p3.pstatp.com/obj/39f4000391e92ac9d46f

**资源离线**

解决了前面的问题，我们接着就是要解决H5的速度/性能问题，尽可能快的达到极速&稳定加载。我们先看一下传统流程上，从客户端点击一个cell或者banner到一个网页展现在用户手机上需要经过哪些过程。

http://p1.pstatp.com/obj/39f4000397d247797315

从上图我们可以看出，在这个过程中，很大一部分的时间开销是花在网络开销上（红色箭头），特别的是红色的两个关键节点（DNS解析，加载资源js/css/image）。
DNS解析需要一层一层往上查找直到顶级域名服务器，过程中需要经过比较多的运营商节点，经常也会遇到很多的劫持问题，影响请求达到率和引起用户反馈。
关于静态资源加载，在网页上，实际上HTML文档和API数据请求所占的大小和带宽都非常小，带宽消耗的大户是各类静态资源（js/css/image）等。
所以做优化我们第一步是先从大头的入手，解决资源加载的问题。这一块业内通用方案都是离线化，即是把资源文件提前下发到客户端，当需要加载资源文件的时候，从客户端本地读取，这样一来所有的资源传输网络时延，基本就都变成了客户端本地磁盘读取的IO时间了，基本上可以是 百毫秒 级别，甚至 十毫秒。进一步的，html文档也是一种资源，我们可以把html文档也离线化，这样一来除了异步数据之外，所以的时延就都是本地磁盘读写时间，我们的加载过程就变成这样：

http://p1.pstatp.com/obj/39f0000732ad9b40304a

为了印证我们这个修改方案的有效性，我们特意拿一个线上页面比较复杂的页面做了一个demo实验，选用的是火山小视频 - 直播金主排行榜页面。我们在线上有这个页面的性能监控，可以得到线上这个页面的DOM ready时延和load时延，我们将它改成了离线版，然后在客户端上加载离线版页面，打点计算这两个时间，得到离线版的时延测试数据。

**域名拦截**

关于URL的思考
到上面这一步，我们测试离线包的时候使用的还是file协议打开本地文件，虽然这种做法没什么毛病，但是我们觉得这种做法有些不够极致：
1. URL是file:// 开头的不好看，不优雅；
2. 客户端内很多URL都是服务端下发的，下发file:// 协议的，服务端必须要知道客户端的绝对路径；
3. iOS平台和Android平台有一定的差异性，文件存储位置不同，无法共用一个相同的绝对地址，如果只维护最后的文件名，iOS打开 file://AAA/target.html，Android打开 file://BBB/target.html，又不太好后续维护和扩展；
4. 使用file协议的话，如果离线包没有下载成功或者离线资源缺失/格式错误，客户端内打开不存在/有问题的文件资源就会出问题，也没有降级服务方案，这意味着最少需要在客户端内内置一个保底的离线包；
5. 安全性，使用file:// 协议的是一个绝对路径，没有域名一说，对于JSBridge的话就没有办法做鉴权，也就意味着桥接层，需要对file:// 协议的地址单独开一个白名单特权，不利于权限收敛。
所以我们决定做 域名拦截。
简单说，就是我们在客户端里打开离线网页地址是正常的http/https链接，如：
https://hotsoon.snssdk.com/falcon/live_app/page/inapp/rank_rich_anchor.html
然后走的逻辑流程跟file:// 差不多。
跟客户端同学经过调研之后，我们知道不管是iOS还是Android，在Webview上都是可以拿到请求URL的。所以我们决定在Webview上做一个域名拦截，同时将Webview在客户端上做一层封装成为IESWebview。IESWebview是一个SDK，主要做的是离线化域名拦截和注入基于注册机制实现JSBridge。
