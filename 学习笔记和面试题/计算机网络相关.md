#### 1.http的特点--无连接，媒体独立，无状态

（1）HTTP是无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。
（2）HTTP是媒体独立的：只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。
（3）HTTP是无状态：无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。

#### 2.HTTP客户端请求消息和服务端响应消息

**客户端请求消息**
请求行、请求头部、空行和请求数据。

1.请求行request line：
2.请求头部request header：包含许多有关的客户端环境和请求正文的有用信息。例如，请求头可以声明浏览器所用的语言，请求正文的长度等。
3.空行：它表示请求头已经结束，接下来的是请求正文
4.请求数据：请求正文中可以包含客户提交的查询字符串信息

下面是一个HTTP请求的例子：
GET/sample.jspHTTP/1.1   ---请求方法“GET”代表请求方法，“/sample.jsp”表示URI，“HTTP/1.1代表协议和协议的版本。
Accept:image/gif.image/jpeg,*/*---请求头
Accept-Language:zh-cn
Connection:Keep-Alive
Host:localhost
User-Agent:Mozila/4.0(compatible;MSIE5.01;Window NT5.0)
Accept-Encoding:gzip,deflate
 
username=jinqiao&password=1234--请求正文

**服务端响应消息**
状态行、消息报头、空行和响应正文。

状态行：  版本号 状态码 原因 [回车换行]  HTTP/1.1 200 OK\r\n
响应头：
空行：它表示响应头已经结束，接下来的是响应正文
响应正文：

HTTP/1.1 200 OK
Server: nginx/0.6.39
Date: wed, 04 Sep 2013 02:25:05 GMT
Content-Type: text/plain
Content-Length: 118
Connection: close
Vary: Accept-Encoding
[CRLF]

响应头信息：
Allow	：服务器支持哪些请求方法（如GET、POST等）。
Content-Encoding：文档的编码（Encode）方法。
Content-Length	：表示内容长度
Content-Type	：表示后面的文档属于什么MIME类型。Servlet默认为text/plain，但通常需要显式地指定为text/html。
Last-Modified	：文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304（Not Modified）状态。
Expires	：应该在什么时候认为文档已经过期，从而不再缓存它？
Refresh	：表示浏览器应该在多少时间之后刷新文档，以秒计。
#### 3.HTTP请求方法

GET 请求资源，请求指定的页面信息，并返回实体主体。
HEAD  类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头
POST  添加内容，向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。
PUT 修改内容，从客户端向服务器传送的数据取代指定的文档的内容。
DELETE  删除内容，请求服务器删除指定的页面。
CONNECT HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。
OPTIONS 询问可以执行哪些方法，允许客户端查看服务器的性能。
TRACE   回显服务器收到的请求，主要用于测试或诊断。

#### 4.http状态码

HTTP状态码的作用是：web服务器用来告诉客户端，发生了什么事。

HTTP状态码分为五类：
1xx--请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束。
2xx--成功，代表请求已成功被服务器接收、理解、并接受。
   --200 ：服务器已成功处理了请求并提供了请求的网页。
   --204： 服务器成功处理了请求，但没有返回任何内容。
3xx--重定向，这类状态码代表需要客户端采取进一步的操作才能完成请求。
   --301： 请求的网页已永久移动到新位置。当URLs发生变化时，使用301代码。搜索引擎索引中保存新的URL。 
   --302： 请求的网页临时移动到新位置。搜索引擎索引中保存原来的URL。 
   --304： 如果网页自请求者上次请求后没有更新，则用304代码告诉搜索引擎机器人，可节省带宽和开销。
4xx--客户端错误，客户端看起来可能发生了错误，妨碍了服务器的处理。
   --400： 服务器不理解请求的语法
   --403： 服务器拒绝请求。 
   --404： 服务器找不到请求的网页。服务器上不存在的网页经常会返回此代码。 
   --410 ：请求的资源永久删除后，服务器返回此响应。该代码与 404（未找到）代码相似，但在资源以前存在而现在不存在的情况下，有时用来替代404 页面代码。如果资源已永久删除，应当使用 301 指定资源的新位置。
5xx--服务器错误，服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。
   --500 ：服务器遇到错误，无法完成请求。 
   --503： 服务器目前无法使用（由于超载或停机维护）。

#### 5.浏览器缓存

**和缓存有关的字段**
通用首部字段：
cache-control：控制缓存的行为

请求首部字段：
if-match：比较ETag是否一致
if-none-match：比较ETAG是否不一致
if-modified-since：比较资源最后更新的时间是否一致
if-unmodified-since：比较资源最后更新的时间是否一致

响应首部字段：
etag：资源的匹配信息
expire

**缓存的过程**
浏览器的资源请求，如果使用了缓存基本上是两种情况:
1.status code: 200 ok ( from cache )--不发送请求，直接使用本地缓存文件。
2.status code 304 Not Modified--浏览器虽然发现了本地有该资源的缓存，但是不确定是否是最新的，于是想服务器询问，若服务器认为浏览器的缓存版本还可用，那么便会返回304。

判断是否向服务器请求，是否使用缓存的过程：
1.根据Expires与Cache-Control判断是否过期，若没有过期，从缓存中读取。
    Cache-Control：是最重要的规则。这个字段用于指定所有缓存机制在整个请求/响应链中必须服从的指令。
    Expires：头部字段提供一个日期和时间，在该日期前的所有对该资源的请求都会直接使用浏览器缓存而不用向服务器请求（注意：cache-control max-age 和 s-maxage 将覆盖 Expires 头部。）
2.若过期，用Last-Modified/If-Modified-Since来check服务端文件是否更新的第一种方式。如果相同，则响应HTTP304，从缓存读数据；如果不相同文件更新了，HTTP200，返回数据，同时通过响应头更新last-Modified的值（以备下次对比）。
3.若过期，ETag/If-None-Match则是上文大话中说的第二种check服务端文件是否更新的方式，如果相同，则相应HTTP304，客户端直接读取缓存，如果不相同，HTTP200，下载正确的数据，更新ETag值。

**用户行为和缓存**
用户行为与缓存

1.在地址栏按回车:响应HTTP200（from cache），因为有效期还没过直接读取的缓存
2.ctrl+r进行刷新：会跳过cache-control和expires直接对服务器请求，即使文件不变，则会相应HTTP304（Not Modified），虽然还是读取的本地缓存，但是多了一次服务端的请求
3.ctrl+shift+r强刷，则会直接从服务器下载新的文件，响应HTTP200。
4.F5刷新，会忽略Expires/Cache-Control的设置，会再次发送请求去服务器请求，而Last-Modified/Etag还是有效的，服务器会根据情况判断返回304还是200；
5.Ctrl+F5强制刷新的时候，只是所有的缓存机制都将失效，重新从服务器拉去资源。


#### 5. http内容编码Content-Encoding

内容编码机制：
浏览器发送请求时，请求头通过 Accept-Encoding 带上自己支持的内容编码格式列表；
服务端从中挑选一种用来对正文进行编码，并通过 Content-Encoding 响应头指明选定的格式；
浏览器拿到响应正文后，依据 Content-Encoding 进行解压。
当然，服务端也可以返回未压缩的正文，但这种情况不允许返回 Content-Encoding。这个过程就是 HTTP 的内容编码机制。

编码目的：
它可以很好地用于文本类响应正文的压缩，减少网络数据的传输

#### 6.客户端向服务器发送http请求的过程

HTTP(HyperText Transfer Protocol)超文本传输协议,是一套计算机通过网络进行通信的规则。
HTTP客户端(比如web浏览器)  HTTP服务器(比如web服务器)
HTTP通信机制是在一次完整的HTTP通信过程中，Web浏览器与Web服务器之间将完成下列7个步骤：
（1）建立TCP连接
在HTTP工作开始之前，Web浏览器首先要通过网络与Web服务器建立连接，该连接是通过TCP来完成的，该协议与IP协议共同构建Internet，即著名的TCP/IP协议族，因此Internet又被称作是TCP/IP网络。HTTP是比TCP更高层次的应用层协议，根据规则，只有低层协议建立之后才能，才能进行更层协议的连接，因此，首先要建立TCP连接，一般TCP连接的端口号是80

（2）Web浏览器向Web服务器发送请求命令
一旦建立了TCP连接，Web浏览器就会向Web服务器发送请求命令
例如：GET/sample/hello.jsp HTTP/1.1

（3）Web浏览器发送请求头信息
浏览器发送其请求命令之后，还要以头信息的形式向Web服务器发送一些别的信息，之后浏览器发送了一空白行来通知服务器，它已经结束了该头信息的发送。

（4）Web服务器应答
客户机向服务器发出请求后，服务器会客户机回送应答，
HTTP/1.1 200 OK
应答的第一部分是协议的版本号和应答状态码

（5）Web服务器发送应答头信息
正如客户端会随同请求发送关于自身的信息一样，服务器也会随同应答向用户发送关于它自己的数据及被请求的文档。

（6）Web服务器向浏览器发送数据
Web服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据

（7）Web服务器关闭TCP连接
一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码
Connection:keep-alive
TCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。

#### 1.一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？

输入地址
1.把URL分割成几个部分：协议、网络地址、资源路径。其中网络地址指示该连接网络上哪一台计算机，可以是域名或者IP地址，可以包括端口号；
        例如：http://www.guokr.com/question/554991/
        协议部分：http
        网络地址：www.guokr.com
        资源路径：/question/554991/
2.如果地址不是一个IP地址，通过DNS（域名系统）将该地址解析成IP地址。
        IP地址对应着网络上一台计算机，DNS服务器本身也有IP，你的网络设置包含DNS服务器的IP。
        例如：www.guokr.com 不是一个IP，向DNS询问请求www.guokr.com 对应的IP
        获得IP： 111.13.57.142。
3.发送http请求(讲解http请求的过程)
4.服务器响应请求，将数据返回給浏览器。里面包含页面的布局、文字。数据也可能是图片、脚本程序等。
5.Web服务器提供资源服务，客户端开始下载资源。
随后浏览器会解析HTML生成DOM Tree，其次会根据CSS生成CSSRule Tree，而javascript又可以根据DOMAPI操作DOM

#### 7.TCP和UDP的区别

TCP(Transmission Control Protocol)传输控制协议
UDP(User Data Protocol)用户数据报协议

1、双方都是一种网络传输协议
2、TCP需要建立连接，而UDP不需要建立连接（无连接传输）
3、是否建立真实连接的特性，造成了双方可靠性的差距。
　　 TCP属于可靠的传输协议：因为传输前双方建立好了连接，相当于买卖双方建立好了交易合同，传输中一般不会出现意外，直到连接终止；
　　 UDP属于不可靠的传输协议：UDP的所谓连接相当于一种映射，UDP单方面的认为目标地址（端口）是可用的，从而进行收发数据，而实际上目标地址（端口）未必可用，所以传输数据不可靠

　　4、由于TCP需要建立真实的连接，所以需要消耗服务器的负载要大于UDP

#### 8.TCP协议中的三次握手和四次挥手

tcp三个阶段：建立连接(三次握手)、数据传输、释放连接(四次握手);

建立TCP需要三次握手才能建立，而断开连接则需要四次握手。

**建立连接(三次握手)**

1.客户端发送一个带SYN(同步)标志的TCP报文到服务器
2.服务器端回应客户端的，这是三次握手中的第2个报文，这个报文同时带ACK标志和SYN标志。
3.客户必须再次回应服务段一个ACK报文，这是报文段3。并分配资源，这样TCP连接就建立了。

**释放连接(四次握手)**

1.假设Client端发起中断连接请求，也就是发送FIN报文。Server端接到FIN报文后，意思是说"我Client端没有数据要发给你了"，但是如果你还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。
2.Server先发送ACK，"告诉Client端，你的请求我收到了，但是我还没准备好，请继续你等我的消息"。这个时候Client端就进入FIN_WAIT状态，继续等待Server端的FIN报文。
3.当Server端确定数据已发送完成，则向Client端发送FIN报文。"告诉Client端，好了，我这边数据发完了，准备好关闭连接了"
4.Client端收到FIN报文后，"就知道可以关闭连接了，但是他还是不相信网络，怕Server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。“，Server端收到ACK后，"就知道可以断开连接了"。Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了。

**为什么连接的时候是三次握手，关闭的时候却是四次握手？**

因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。

**为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？**

虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。

http://m.blog.csdn.net/article/details?id=6667471

#### 9.集线器和交换机

集线器：共享带宽  交换机：独享带宽

集线器采用的是共享带宽的工作方式，简单打个比如，集线器就好比一条单行道，“10M”的带宽分多个端口使用，当一个端口占用了大部分带宽后，另外的端口就会显得很慢。
交换机和路由器是一个独享的通道，它能确保每个端口使用的带宽，如百兆的交换机，它能确保每个端口都有百兆的带宽。
正因为交换机比集线器有着明显的优势，目前的集线器可说绝迹市场了

有10个站连接到以太网上。试计算以下三种情况下每一个站所能得到的带宽。
（1）10个站都连接到一个10Mb/s以太网集线器--1Mb/s
（2）10个站都连接到一个100Mb/s以太网集线器--10Mb/s
（3）10个站都连接到一个10Mb/s以太网交换机--10Mb/s

#### 10.七层协议

物理层
数据链路层
网络层(IP协议、ICMP协议、ARP协议、RARP协议。)
传输层(TCP协议、UDP协议)
会话层
表示层
应用层(FTP、Telnet、SMTP、HTTP、RIP、NFS、DNS。)
     (http)--HTTPS（securely transferring web pages）服务器，默认的端口号为443/tcp 443/udp
