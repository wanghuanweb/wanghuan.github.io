前端模块化分为几种：
1.css模块化
2.js模块化

**css模块化**

CCS模块将作用域限制于组件中，从而避免了全局作用域的问题

**js模块化**

1.js模块规范有AMD,CMD,commonJS

CommonJS主要是为了后端模块化开发，加载时从磁盘中加载可以同步
AMD主要是为了浏览器端模块开发，是异步的模块加载机制。Amd推崇依赖前置。Amd对加载的模块是提前读取并加载。
CMD主要是为了浏览器端模块开发，是异步的模块加载机制。CMD推崇依赖就近。Cmd对加载的模块是提前读取并不加载，而是在需要时加载。也就是懒加载

CommonJS
CommonJS定义的模块分为:{模块引用(require)} {模块定义(exports)} {模块标识(module)}
```
//sum.js
exports.sum = function(){...做加操作..};

//calculate.js
var math = require('sum');
exports.add = function(n){
    return math.sum(val,n);
};
```

AMD
define(id?, dependencies?, factory);
依赖参数：
是个定义中模块所依赖模块的数组。本规范定义了三种特殊的依赖关键字。如果"require","exports", 或 "module"出现在依赖列表中，参数应该按照CommonJS模块规范自由变量去解析。
```
//有"require","exports", 或 "module"依赖关键字，默认commonJS去解析
define("alpha", ["require", "exports", "beta"], function (require, exports, beta) {
     exports.verb = function() {
         return beta.verb();
         //Or:
         return require("beta").verb();
     }
 });
```

```
//定义了依赖数组，返回一个对象
define(["alpha"], function (alpha) {
    return {
      verb: function(){
        return alpha.verb() + 2;
      }
    };
});
```

CMD
接口define(function(require,exports,module){...});
```
define(function(require, exports, module) {   
    var a = require('./a')   
    a.doSomething()   
    // 此处略去 100 行  
    var b = require('./b')
    // 依赖可以就近书写   
    b.doSomething()   
    // ...
 })
```
