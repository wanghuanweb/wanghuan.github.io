**单例模式**--一个类只有一个实例，并且提供全局访问

定义：
保证一个类(对象)只有一个实例，并提供一个访问他的全局访问点。

原理：
1.利用闭包保存对一个局部变量的引用，这个变量保持着首次创建的唯一实例
2.

用于：
全局缓存，登录浮窗只需要唯一一个实例的时候。

惰性单例模式:
只有在需要的时候才创建单例

```
//通用惰性单例的创建方法
var getSingle = function(foo){
  var single = null;
  return function(){
    return single || (single = foo.apply(this,arguments));
  }
};
//用法
var createLoginLayer = function(){
  var frag = document.createDocumentFragment();
  var div = document.createElement('div');
  div.style.display = 'none';
  //以下给div添加其它登录元素
  ...
  document.body.appendChild(frag.appendChild(div));
  return div;
}
var createSingleLoginLayer = getSingle(createLoginLayer);
//当用户第一次点击按钮(id = 'lgBtn')时，来创建并显示登录窗口，之后重复点击按钮不会重复创建；
document.getElementById('lgBtn').onclick = function(){
  var lg = createSingleLoginLayer();
  lg.style.display = 'block';
}
```

缓存函数的计算结果，如计算一个数的数列
以下是不缓存的写法，非常慢！
```
function foo(n){
  results = n < 2 ? n : foo(n - 1) + foo(n - 2);
  return results;
}
console.log(foo(40));//得计算好几秒
```
以下是缓存写法，基本瞬间出结果！
```
var foo = (function(){
  var cache = {};
  return function(n){
    if(!cache[n]){
      cache[n] = n < 2 ? n : foo(n - 1) + foo(n - 2);
    }
    return cache[n];
  };
})();
console.log(foo(100));
```
