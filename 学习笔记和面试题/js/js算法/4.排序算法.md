冒泡排序
快速排序
直接插入，折半插入，
希尔排序
简单选择排序
堆排序
归并排序
基数排序

稳定性：待排序的序列中，存在多个相同关键字的记录，排序后，相对次序保存不变则是稳定的。

稳定性的好处

稳定性排序：冒泡排序，直接插入，折半插入，归并排序，基数排序
不稳定排序：快速排序，希尔排序，选择排序，堆排序

1.冒泡排序（Bubble Sort）

基本思想：它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来,较大的放在后边。
什么时候最快（Best Cases）：当输入的数据已经是正序时
什么时候最慢（Worst Cases）：当输入的数据是反序时

```
function bubbleSort(arr) {
    var len = arr.length;

    for(var i = 0;i < len;i++) {
        for(var j = i+1;j < len;j++) {
            if(arr[i] > arr[j]) {
                var temp = arr[j];
                arr[j] = arr[i];
                arr[i] = temp;
            }
        }
    }
    return arr;
}
```

2.快速排序（Quick Sort）

基本思想：通过一趟排序将数据分成两个部分，其中一个部分的所有数据都要小于另外一个部分的所有数据。然后分别对两个部分分别进行快排。

处理大数据最快的排序算法之一。最差复杂度是O(n²)，平均复杂度O(nlogn)。

且O(nlogn)记号中隐含的常数因子很小，比复杂度稳定等于O(n log n)的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。
```
function quickSort(arr) {
    var len = arr.length,
        base = arr[0],
        leftArr = [],
        rightArr = [];

    if(len <= 1){
        return arr;
    }

    for(var i = 1;i < len;i++) {
        if(arr[i] > base) {
            rightArr.push(arr[i]);
        } else{
            leftArr.push(arr[i]);
        }
    }

    return [].concat(quickSort(leftArr),base,quickSort(rightArr));
}
```


3.选择排序（Selection Sort）

在时间复杂度上表现最稳定的排序算法之一，因为无论什么数据进去都是O(n²)的时间复杂度。。。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。

```
function selectionSort(arr) {    var len = arr.length;    var minIndex, temp;    for (var i = 0; i < len - 1; i++) {
        minIndex = i;        for (var j = i + 1; j < len; j++) {            if (arr[j] < arr[minIndex]) {     //寻找最小的数
                minIndex = j;                 //将最小数的索引保存
            }
        }
        temp = arr[i];
        arr[i] = arr[minIndex];
        arr[minIndex] = temp;
    }    return arr;
}
```


3.插入排序（Insertion Sort）
插入排序须知：

```
function insertionSort(arr) {    
    var len = arr.length;    
    var preIndex, current;    
    for (var i = 1; i < len; i++) {
        preIndex = i - 1;
        current = arr[i];       
         while(preIndex >= 0 && arr[preIndex] > current) {
            arr[preIndex+1] = arr[preIndex];
            preIndex--;
        }
        arr[preIndex+1] = current;
    }    
    return arr;
}
```

前面列举了3种前端开发中的用javascript写的算法排序，今天继续更新3种。
计数排序（Counting Sort）
计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。
作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。
(1)算法简介

计数排序(Counting sort)是一种稳定的排序算法。计数排序使用一个额外的数组C，其中第i个元素是待排序数组A中值等于i的元素的个数。然后根据数组C来将A中的元素排到正确的位置。它只能对整数进行排序。
(2)算法描述和实现

具体算法描述如下：

<1>. 找出待排序的数组中最大和最小的元素；
<2>. 统计数组中每个值为i的元素出现的次数，存入数组C的第i项；
<3>. 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；
<4>. 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。
(3)算法分析

当输入的元素是n 个0到k之间的整数时，它的运行时间是 O(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。
最佳情况：T(n) = O(n+k)
最差情况：T(n) = O(n+k)
平均情况：T(n) = O(n+k)

```
function countingSort(arr, maxValue) {    var bucket = new Array(maxValue+1),
        sortedIndex = 0;
        arrLen = arr.length,
        bucketLen = maxValue + 1;    for (var i = 0; i < arrLen; i++) {        if (!bucket[arr[i]]) {
            bucket[arr[i]] = 0;
        }
        bucket[arr[i]]++;
    }    for (var j = 0; j < bucketLen; j++) {        while(bucket[j] > 0) {
            arr[sortedIndex++] = j;
            bucket[j]--;
        }
    }    return arr;
}
```


归并排序（Merge Sort）
归并排序须知：
作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：
自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第2种方法）
自下而上的迭代
在《数据结构与算法JavaScript描述》中，作者给出了自下而上的迭代方法。但是对于递归法，作者却认为：

简而言之，就是JavaScript没有对递归进行优化。运用递归函数不仅没有运行速度上的优势，还可能造成程序运行失败。因此不建议使用递归。
和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(n log n）的时间复杂度。代价是需要额外的内存空间。
```
function mergeSort(arr) {  //采用自上而下的递归方法
    var len = arr.length;    if(len < 2) {        return arr;
    }    var middle = Math.floor(len / 2),        left = arr.slice(0, middle),        right = arr.slice(middle);    return merge(mergeSort(left), mergeSort(right));
}

function merge(left, right)
{    var result = [];    while (left.length>0 && right.length>0) {        if (left[0] <= right[0]) {
            result.push(left.shift());
        } else {
            result.push(right.shift());
        }
    }    while (left.length)
        result.push(left.shift());    while (right.length)
        result.push(right.shift());    return result;
}
```
