图（Graph）是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G(V,E)，其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合。

1.图的构造函数
   vertex类用来保存顶点和边，这个类的作用与链表和二叉搜索树的 Node 类一样。
   graph类用邻接表数组保存边

2.原型方法
    has(element):如果值在集合中，返回true,否则返回false
    add(element):向集合添加一个新的项
    delete(element):从集合移除一个值
    clear():移除集合中的所有项
    size():返回集合所包含的元素数量，与数组的length属性相似
    values():返回一个集合中所有值的数组
    union(otherSet):并集，返回包含两个集合所有元素的新集合(元素不重复)
    intersection(otherSet):交集，返回包含两个集合中共有的元素的集合、
    difference(otherSet):差集，返回包含所有存在本集合而不存在setName集合的元素的新集合
    subset(otherSet):子集，验证setName是否是本集合的子集

```
function Vertex(element){
    this.element = element;
}
function Graph(v){
    this.vertexes = v;
    this.edges = 0;
    this.adj = [];
    //通过 for 循环为数组中的每个元素添加一个子数组来存储所有的相邻顶点， 并将所有元素初始化为空字符串
    for(var i =0;i <= this.vertexes;i++){
        this.adj[i] = [];
        this.adj[i].push('');
    }

    //保存已访问过的顶点，为深度和广度访问做准备
    this.marked = [];
    for(var i =0;i < this.vertexes;i++){
        this.marked[i] = false;
    }

     //最短距离，保存一个顶点到下一个顶点的所有边  
    this.edgeTo = [];
}
Graph.prototype.addEdge = function(v,w){
    this.adj[v].push(w);
    this.adj[w].push(v);
    this.edges++;
}
//访问一个没有访问过的顶点， 将它标记为已访问， 再递归地去访问在初始顶点的邻接表中其他没有访问过的顶点,如此往复， 直到没有路径为止
Graph.prototype.dfs = function(v){
    this.marked[v] = true;
    if(this.adj[v] != undefined){
        console.log(v);
        for(var i in this.adj[v]){
            if(!this.marked[i]){
                this.dfs(i);
            }
        }
    }
}
Graph.prototype.bfs = function(s){
    var queue = [];
    this.marked[s] = true;
    queue.push(s);

    while(queue.length > 0){
        var v = queue.shift();
        if(typeof v != 'string'){
            console.log(v);
        }
        for(var i in this.adj[v]){
            if(!this.marked[i]){
                this.edgeTo[i] = v;
                this.marked[i] = true;
                queue.push(w);
            }
        }
    }
}


```
