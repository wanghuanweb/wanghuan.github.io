##### 1.谈一谈你对ECMAScript6的了解？ECMAScript6的基础知识。

ECMAScript 6（以下简称ES6）是JavaScript语言的下一代标准.
因为当前版本的ES6是在2015年发布的，所以又称ECMAScript 2015。
若是2016年发布的，就是ECMAScript 2016。

Babel是一个广泛使用的ES6转码器，可以将ES6代码转为ES5代码。目前并不是所有浏览器都能兼容ES6全部特性

###### 1.let和const

let的作用：
1.块级作用域，不存在变量提升--块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要了。
2.循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。
3.暂存性死区
4.不允许重复声明

---块级作用域，不存在变量提升
```
var name = 'zach'
while (true) {
    var name = 'obama'
    console.log(name)  //obama
    break
}
console.log(name)  //obama

用let如下：
let name = 'zach'
while (true) {
    let name = 'obama'
    console.log(name)  //obama
    break
}
console.log(name)  //zach
```

---循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。
例子1:
```
//另外一个var带来的不合理场景就是用来计数的循环变量泄露为全局变量
var a = [];
for (var i = 0; i < 10; i++) {
  a[i] = function () {
    console.log(i);
  };
}
a[6](); // 10

//上面代码中，变量i是var声明的，在全局范围内都有效。
//因为 let 语句会使该变量处于一个块级作用域中，从而让事件监听回调函数中的变量引用得到保持
//其实若用es5的话，其实可以用闭包就可以解决这个问题
var a = [];
for (let i = 0; i < 10; i++) {
  a[i] = function () {
    console.log(i);
  };
}
a[6](); // 6
```
例子2:
```
for (let i = 0; i < 3; i++) {
  let i = 'abc';
  console.log(i);
}
// abc
// abc
// abc
但如果是var则只会打印出一次abc
```

---暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。
```
if (true) {
  // TDZ开始
  tmp = 'abc'; // ReferenceError
  console.log(tmp); // ReferenceError

  let tmp; // TDZ结束
  console.log(tmp); // undefined

  tmp = 123;
  console.log(tmp); // 123
}
```

---不允许重复声明
let不允许在相同作用域内，重复声明同一个变量。
```
// 报错
function () {
  let a = 10;
  var a = 1;
}

// 报错
function () {
  let a = 10;
  let a = 1;
}
//因此，不能在函数内部重新声明参数。
function func(arg) {
  let arg; // 报错
}

function func(arg) {
  {
    let arg; // 不报错
  }
}
```

const也用来声明变量，但是声明的是常量。一旦声明，常量的值就不能改变。

```
const MY_CONSTANT = 1;
MY_CONSTANT = 2 // Error
const SOME_CONST; // Error
```

注意，对象的属性或数组成员还是可以改变的。

```
const MY_OBJECT = {some: 1};
MY_OBJECT.some = 'body'; // Cool
```
###### 2.函数和箭头函数

**函数**

1.函数参数可以指定默认值
--首先，阅读代码的人，可以立刻意识到哪些参数是可以省略的，不用查看函数体或文档
--其次，有利于将来的代码优化，即使未来的版本在对外接口中，彻底拿掉这个参数，也不会导致以前的代码无法运行。
2.rest参数用来获取多余参数，是个数组。这样可以避免使用arguments对象了。
--注意，rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。
3.箭头函数.
--this指向定义时所在的对象，而不是使用时所在对象
--this指向的固定化，有利于封装回调函数。指向的固定化是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。正是因为它没有this，所以也就不能用作构造函数。
--除了this，以下三个变量在箭头函数之中也是不存在的，指向外层函数的对应变量：arguments、super、new.target。


--函数参数可以指定默认值
es6之前，不能为函数设置默认值，只能采用变通的方法：
```
//但是如果y本身值就是空怎么办呢？就会有错误啊
function log(x, y) {
  y = y || 'World';
  console.log(x, y);
}

log('Hello') // Hello World
log('Hello', 'China') // Hello China
log('Hello', '') // Hello World
//所以为了避免这个问题，通常需要先判断一下参数y是否被赋值，如果没有，再等于默认值。
if (typeof y === 'undefined') {
  y = 'World';
}
```

ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。
```
function log(x, y = 'World') {
  console.log(x, y);
}

log('Hello') // Hello World
log('Hello', 'China') // Hello China
log('Hello', '') // Hello
```

--rest参数用来获取多余参数
```
// arguments变量的写法
function sortNumbers() {
  return Array.prototype.slice.call(arguments).sort();
}

// rest参数的写法
const sortNumbers = (...numbers) => numbers.sort();
```

--箭头函数

箭头函数是函数的一种简写方式，括号包裹参数，跟随一个=>，紧接着函数体

1.this指向定义时所在的对象，而不是使用时所在对象
2.this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。正是因为它没有this，所以也就不能用作构造函数。也就是说，不可以使用new命令，否则会抛出一个错误。
3.因为没有this，所以call()或者apply()调用箭头函数时，无法对this进行绑定
3.除了this，以下三个变量在箭头函数之中也是不存在的，指向外层函数的对应变量：arguments、super、new.target。arguments如果要用，可以用Rest参数代替。
4.es6的函数都可以定义参数默认值

对于函数中的函数this指向全局对象，之前的解决方法是1.用that缓存 2.用bind(this)绑定 3.用箭头函数

--this指向定义时所在的对象
```
var x = 1,
    obj = {
        x:10,
        test:()=>this.x
    };
console.log(obj.test());  ==== 输出1，因为是在全局定义的

//setTimeout的参数是一个箭头函数，这个箭头函数的定义生效是在foo函数生成时，而它的真正执行要等到100毫秒后。
//如果是普通函数，执行时this应该指向全局对象window，这时应该输出21。
//但是，箭头函数导致this总是指向函数定义生效时所在的对象（本例是{id: 42}），所以输出的是42。
function foo() {
  setTimeout(() => {
    console.log('id:', this.id);
  }, 100);
}
var id = 21;
foo.call({ id: 42 });
// id: 42


//因此，对于函数中的函数this指向全局对象，之前的解决方法是1.用that缓存 2.用bind(this)绑定 3.用箭头函数
function Person(){
  this.age = 0;

  setInterval(() => {
    // |this| 指向 person 对象
    this.age++;
  }, 1000);
}

var person = new Person();


//function Timer() {
  this.s1 = 0;
  this.s2 = 0;
  // 箭头函数
  setInterval(() => this.s1++, 1000);
  // 普通函数
  setInterval(function () {
    this.s2++;
  }, 1000);
}

var timer = new Timer();

setTimeout(() => console.log('s1: ', timer.s1), 3100);
setTimeout(() => console.log('s2: ', timer.s2), 3100);
// s1: 3
// s2: 0
```

--this指向的固定化
```
//箭头函数可以让this指向固定化，这种特性很有利于封装回调函数。下面是一个例子，DOM 事件的回调函数封装在一个对象里面。
var handler = {
  id: '123456',

  init: function() {
    document.addEventListener('click',
      event => this.doSomething(event.type), false);
  },

  doSomething: function(type) {
    console.log('Handling ' + type  + ' for ' + this.id);
  }
};
//上面代码的init方法中，使用了箭头函数，这导致这个箭头函数里面的this，总是指向handler对象。否则，回调函数运行时，this.doSomething这一行会报错，因为此时this指向document对象。

//call和apply不能对this进行绑定
var obj = {
    birth: 1990,
    getAge: function (year) {
        var b = this.birth; // 1990
        var fn = (y) => y - this.birth; // this.birth仍是1990
        return fn.call({birth:2000}, year);
    }
};
obj.getAge(2015); // 25
```

--除了this，arguments、super、new.target三个变量不存在。指向外层函数对应的变量
```
//除了this，以下三个变量在箭头函数之中也是不存在的，指向外层函数的对应变量：arguments、super、new.target。
function foo() {
  setTimeout(() => {
    console.log('args:', arguments);
  }, 100);
}
foo(2, 4, 6, 8)
// args: [2, 4, 6, 8]
```

###### 3.字符串

1.新增的字符串方法

ES6提供了3种可以替代indexof方法，可以用来确定一个字符串是否包含在另一个字符串中
includes()：返回布尔值，表示是否找到了参数字符串。
startsWith()：返回布尔值，表示参数字符串是否在源字符串的头部。
endsWith()：返回布尔值，表示参数字符串是否在源字符串的尾部。
```
'my string'.startsWith('my'); //true
'my string'.endsWith('my'); // false
'my string'.includes('str'); // true
```

repeat():返回一个新字符串，表示将原字符串重复n次
```
'x'.repeat(3) // "xxx"
'hello'.repeat(2) // "hellohello"
'na'.repeat(0) // ""
```

2.字符串模板--提供一个简洁的方式来实现字符串插值${}和``

ES5:在其它语言中，使用模板和插入值是在字符串里面输出变量的一种方式。因此，在ES5，我们可以这样组合一个字符串'' + variable等

ES6:幸运的是，在ES6中，我们可以使用新的语法$ {NAME}，并把它放在反引号里：
```
//es5
var name = 'Your name is ' + first + ' ' + last + '.';
var url = 'http://localhost:3000/api/messages/' + id;
//es6
var name = `Your name is ${first} ${last}. `;
var url = `http://localhost:3000/api/messages/${id}`;
```

3.多行字符串

```
//ES6的多行字符串是一个非常实用的功能。在ES5中，我们不得不使用以下方法来表示多行字符串：

var roadPoem = 'Then took the other, as just as fair,nt'
    + 'And having perhaps the better claimnt'
    + 'Because it was grassy and wanted wear,nt'
    + 'Though as for that the passing therent'
    + 'Had worn them really about the same,nt';
var fourAgreements = 'You have the right to be you.n
    You can only be you when you do your best.';

//然而在ES6中，仅仅用反引号就可以解决了：

var roadPoem = `Then took the other, as just as fair,
    And having perhaps the better claim
    Because it was grassy and wanted wear,
    Though as for that the passing there
    Had worn them really about the same,`;
var fourAgreements = `You have the right to be you.
    You can only be you when you do your best.`;
```
###### 4.数组

Array 对象增加了一些新的静态方法，Array 原型上也增加了一些新方法。

1.Array.from

Array.from方法用于将两类对象转为真正的数组：类似数组的对象（函数中的 arguments/由 document.getElementByTagName() 返回的 nodeList/新增加的 Map 和 Set 数据结构）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map）。

```
let itemElements = document.querySelectorAll('.items');
let items = Array.from(itemElements);
items.forEach(function(element) {
    console.log(element.nodeType)
});

// A workaround often used in ES5:
let items = Array.prototype.slice.call(itemElements);
```

2.Array.of()

Array.of方法用于将一组值，转换为数组。

```
Array.of(3, 11, 8) // [3,11,8]
Array.of(3) // [3]
Array.of(3).length // 1
Array.of() // []
Array.of(undefined) // [undefined]
Array.of(1) // [1]
Array.of(1, 2) // [1, 2]
```
这个方法的主要目的，是弥补数组构造函数Array()的不足。因为参数个数的不同，会导致Array()的行为有差异。

```
Array() // []
Array(3) // [, , ,]
Array(3, 11, 8) // [3, 11, 8]
```

Array.of基本上可以用来替代Array()或new Array()，并且不存在由于参数不同而导致的重载。它的行为非常统一。

3.find()和findIndex()

find 返回回调返回 true 的第一个元素。
findIndex 返回回调函数返回 true的第一个元素的下标。
fill 用所给参数“覆盖”数组的元素。

数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。

```
[1, 4, -5, 10].find((n) => n < 0)
// -5

[1, 5, 10, 15].find(function(value, index, arr) {
  return value > 9;
}) // 10
[5, 1, 10, 8].find(n => n === 10) // 10

[5, 1, 10, 8].findIndex(n => n === 10) // 2

[0, 0, 0].fill(7) // [7, 7, 7]
[0, 0, 0, 0, 0].fill(7, 1, 3) // [0, 7, 7, 7, 0]
```
###### 5.Spread和Rest操作符(...)

spread操作符主要用于数组构造和解构，在调用时将数组填入函数参数
rest操作符主要用于获得传递给函数的参数列表

```
//rest操作符
function countArguments(...args) {  
　　return args.length;
}
// 获得参数的数量
countArguments('welcome', 'to', 'Earth'); // => 3  

//spread操作符
let cold = ['autumn', 'winter'];  
let warm = ['spring', 'summer'];  
// 构造一个数组
[...cold, ...warm] // 真正数组值是 ['autumn', 'winter', 'spring', 'summer']
// 解构一个数组
let otherSeasons, autumn;  
[autumn, ...otherSeasons] = cold;
otherSeasons      // 值是 ['winter']  
// 代表一个数组的函数参数
cold.push(...warm);  
cold              // 值是 ['autumn', 'winter', 'spring', 'summer']  
```

其实可以很好的简化之前的代码，因为arguments是类数组

```
function f(x, y, z) {
    return x + y + z;
}

var args = [1, 2, 3];

// Old method
func.apply(this, args);
// New method
func(...args);
```
###### 6.解构

解构提供了一个方便地从对象或数组中提取数据的方法

```
let [x, y] = [1, 2]; // x = 1, y = 2
// ES5 equivalent:
var arr = [1, 2];
var x = arr[0];
var y = arr[1];

let x = 1,
   y = 2;
[x, y] = [y, x]; // x = 2, y = 1

let obj = {x: 1, y: 2};
let {x, y} = obj; // x = 1, y = 2

let obj = {x: 1, y: 2};
let {x: a, y: b} = obj; // a = 1, b = 2

function doSomething() {
   return [1, 2]
}
let [x, y] = doSomething(); // x = 1, y = 2
```
###### 7.Promise以及和回调比较的优缺点

promise优点：
1.promise是异步编程的解决方案，避免了层层嵌套的回调，让异步流程以同步操作的流程表达出来
2.Promise简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。
3.Promise提供统一的 API，各种异步操作都可以用同样的方法进行处理。

promise缺点：
1.无法取消Promise，一旦新建它就会立即执行，无法中途取消。
2.如果不设置回调函数，Promise内部抛出的错误，不会反应到外部

下面是一个简单的用setTimeout()实现的异步延迟加载函数:(异步+回调)

```
//ES5
setTimeout(function(){
  console.log('Yay!');
}, 1000);
//ES6
var wait1000 =  new Promise(function(resolve, reject) {
  setTimeout(resolve, 1000);
}).then(function() {
  console.log('Yay!');
});
```

```
//ES5
setTimeout(function(){
  console.log('Yay!');
  setTimeout(function(){
    console.log('Wheeyee!');
  }, 1000)
}, 1000);
//ES6
var wait1000 =  ()=> new Promise((resolve, reject)=> {setTimeout(resolve, 1000)});
wait1000()
    .then(function() {
        console.log('Yay!')
        return wait1000()
    })
    .then(function() {
        console.log('Wheeyee!')
    });
```

promise对象的三个状态：pending执行中，fulfilled成功，reject拒绝(其中pending为初始状态，fulfilled和rejected为结束状态（结束状态表示promise的生命周期已结束）。)

状态转换关系为：pending->fulfilled，pending->rejected。随着状态的转换将触发各种事件（如执行成功事件、执行失败事件等）

**基本用法**

Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由JavaScript引擎提供，不用自己部署。

Promise实例生成以后，可以用then方法分别指定Resolved状态和Reject状态的回调函数，用then后的回调函数处理resolved或者reject的结果。
```
//promise实例--创建promise的时候就执行函数里边的逻辑了
var promise = new Promise(function(resolve,reject) {
    //...some code
    if(success) {
        resolve(value);
    } else {
        reject(error);
    }
});
//Promise实例生成以后，可以用then方法分别指定Resolved状态和Reject状态的回调函数。
promise.then(function(value){

},function(error){

});

```

Promise 新建后就会立即执行。
```
//Promise新建后立即执行，所以首先输出的是“Promise”。然后，then方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行(就是所谓的主线程继续往下执行)，所以“Resolved”最后输出。
let promise = new Promise(function(resolve, reject) {
  console.log('Promise');
  resolve();
});

promise.then(function() {
  console.log('Resolved.');
});

console.log('Hi!');

// Promise
// Hi!
// Resolved
```

**promise.all**

请求下载文件，每次只能请求下载100条数据

```
// 给每个数据请求都转成promise对象
generaterPromise(count, offset){
    let data = {
        count: count,
        offset: offset
    }

    return new Promise(()=>()).then( res => {
        this.exportData.splice( data.offset, 0,  ...res.data.users );
    });
},
// 这样使用可以保证generaterPromise函数生成的offset是需要的，如果使用for循环只会得到最后一次的变量
let promises = arr.map( ( index )=>{
	return this.generaterPromise( count, count * index);
});
Promise.all( promises ).then( res => {
	this.exportString = EXPORT_STRING.DOWNLOAD;
	this.writeToCSV( this.exportData );
    }).catch( error => {
})
```

###### 8.class, extends, super

这三个特性涉及了ES5中最令人头疼的的几个部分：原型、构造函数，继承.

**引入class目的**

让对象原型的写法更加清晰、更像面向对象编程的语法而已

ES6的类，完全可以看作构造函数的另一种写法,类的数据类型就是函数，类本身就指向构造函数。
```
class Point {
  // ...
}

typeof Point // "function"
Point === Point.prototype.constructor // true
```

**class如何写**

1.class里面有一个constructor方法，这就是构造方法。

2.定义class的方法的时候，前面不需要加上function这个关键字，直接把函数定义放进去了就可以了。

3.方法之间不需要逗号分隔，加了会报错。

```
class baseModel {
  constructor(options, data) { // class constructor，node.js 5.6暂时不支持options = {}, data = []这样传参
    this.name = 'Base';
    this.url = 'http://azat.co/api';
    this.data = data;
    this.options = options;
   }
    getName() { // class method
        console.log(`Class name: ${this.name}`);
    }
}
```

AccountModel 从类baseModel 中继承而来:
```
class AccountModel extends baseModel {
    constructor(options, data) {
        //为了调用父级构造函数，可以毫不费力的唤起super()用参数传递
       super({private: true}, ['32113123123', '524214691']); //call the parent method with super
       this.name = 'Account Model';
       this.url +='/accounts/';
    }
    //如果你想做些更好玩的，你可以把 accountData 设置成一个属性：
    get accountsData() { //calculated attribute getter
    // ... make XHR
        return this.data;
    }
}
```

```
let accounts = new AccountModel(5);
accounts.getName();
console.log('Data is %s', accounts.accountsData);
```
结果令人惊讶，输出是：

Class name: Account Model
Data is  32113123123,524214691

###### 9.模块(export或者import)

ES6之前：模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。
为了实现 AMD 或 CommonJS，你通常需要一个构建步骤或加载器。解决这个问题的工具包括 RequireJS、Browserify 和 WebPack。

ES6：模块功能可以取代 CommonJS 和 AMD 规范。模块设计围绕 export 和 import 关键词
```
// lib/math.js

export function sum(x, y) {
   return x + y;
}
export var pi = 3.141593;
// app.js

import { sum, pi } from "lib/math";
console.log('2π = ' + sum(pi, pi));
```
正如你所见，可以存在多个 export 声明。每一个都要明确地指明输出值的类型（本例中的 function 和 var）。

本例中的 import 声明使用一种语法（类似解构）来明确定义被导入的内容。可以使用 * 通配符，结合 as 关键词给模块提供一个本地名称，把模块当成一个整体导入。
```
// app.js

import * as math from "lib/math";
console.log('2π = ' + math.sum(math.pi, math.pi));
```
模块系统有一个 default 输出。它可以是一个函数。只需要提供一个本地名称就可以导入这个默认值（即无解构）：
```

// lib/my-fn.js

export default function() {
   console.log('echo echo');
}

// app.js

import doSomething from 'lib/my-fn';
doSomething();
```
请注意 import 声明是同步的，但是模块代码需在所有依赖加载完后才会运行。

###### 10. Generators

Generator 函数是 ES6 的新特性，它允许一个函数返回的可遍历对象生成多个值。

在使用中你会看到 * 语法和一个新的关键词 yield:
```
function *infiniteNumbers() {
  var n = 1;
  while (true){
    yield n++;
  }
}

var numbers = infiniteNumbers(); // returns an iterable object

numbers.next(); // { value: 1, done: false }
numbers.next(); // { value: 2, done: false }
numbers.next(); // { value: 3, done: false }
```

###### 11.迭代器（Iterators）
迭代器允许每次访问数据集合的一个元素，当指针指向数据集合最后一个元素是，迭代器便会退出。它提供了 next() 函数来遍历一个序列，这个方法返回一个包含 done 和value 属性的对象。

ES6 中可以通过 Symbol.iterator 给对象设置默认的遍历器，无论什么时候对象需要被遍历，执行它的 @@iterator 方法便可以返回一个用于获取值的迭代器。

```
var arr = [11,12,13];
var itr = arr[Symbol.iterator]();

itr.next(); // { value: 11, done: false }
itr.next(); // { value: 12, done: false }
itr.next(); // { value: 13, done: false }

itr.next(); // { value: undefined, done: true }
```
你可以通过 [Symbol.iterator]() 自定义一个对象的迭代器。

###### 12.Map 和 WeakMap
ES6 中两种新的数据结构集：Map 和 WeakMap。事实上每个对象都可以看作是一个Map。

一个对象由多个 key-val 对构成，在 Map 中，任何类型都可以作为对象的 key，如：
```
var myMap = new Map();

var keyString = "a string",
    keyObj = {},
    keyFunc = function () {};

// 设置值
myMap.set(keyString, "value 与 'a string' 关联");
myMap.set(keyObj, "value 与 keyObj 关联");
myMap.set(keyFunc, "value 与 keyFunc 关联");

myMap.size; // 3

// 获取值
myMap.get(keyString);    // "value 与 'a string' 关联"
myMap.get(keyObj);       // "value 与 keyObj 关联"
myMap.get(keyFunc);      // "value 与 keyFunc 关联"
```
WeakMap

WeakMap 就是一个 Map，只不过它的所有 key 都是弱引用，意思就是 WeakMap 中的东西垃圾回收时不考虑，使用它不用担心内存泄漏问题。

另一个需要注意的点是，WeakMap 的所有 key 必须是对象。它只有四个方法delete(key),has(key),get(key) 和 set(key, val)：
```
let w = new WeakMap();
w.set('a', 'b');
// Uncaught TypeError: Invalid value used as weak map key

var o1 = {},
    o2 = function(){},
    o3 = window;

w.set(o1, 37);
w.set(o2, "azerty");
w.set(o3, undefined);

w.get(o3); // undefined, because that is the set value

w.has(o1); // true
w.delete(o1);
w.has(o1); // false
```

###### 13.Set 和 WeakSet
Set 对象是一组不重复的值，重复的值将被忽略，值类型可以是原始类型和引用类型：
```
let mySet = new Set([1, 1, 2, 2, 3, 3]);
mySet.size; // 3
mySet.has(1); // true
mySet.add('strings');
mySet.add({ a: 1, b:2 });

可以通过 forEach 和 for...of 来遍历 Set 对象：

mySet.forEach((item) => {
  console.log(item);
    // 1
    // 2
    // 3
    // 'strings'
    // Object { a: 1, b: 2 }
});

for (let value of mySet) {
  console.log(value);
    // 1
    // 2
    // 3
    // 'strings'
    // Object { a: 1, b: 2 }
}
```

Set 同样有 delete() 和 clear() 方法。

WeakSet
类似于 WeakMap，WeakSet 对象可以让你在一个集合中保存对象的弱引用，在WeakSet 中的对象只允许出现一次：
```
var ws = new WeakSet();
var obj = {};
var foo = {};

ws.add(window);
ws.add(obj);

ws.has(window); // true
ws.has(foo);    // false, foo 没有添加成功

ws.delete(window); // 从结合中删除 window 对象
ws.has(window);    // false, window 对象已经被删除
```
