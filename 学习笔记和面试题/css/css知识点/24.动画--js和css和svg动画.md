#### 1.动画的分类

1.js动画
  DOM动画
  Canvas动画
2.css3动画
  transition
  animation
3.SVG动画

**最佳循环间隔**

17ms。因为大多数显示器的刷新频率是60HZ，相当于每秒钟重绘60次。一般不超过显示器的刷新频率但最接近刷新频率则是最平滑动画的间隔，1000ms/60=17ms。

**动画的本质**

动画的本质不是运动，仅仅是基于定时器对元素状态进行的瞬间改变。
定时器改变元素的属性
浏览器/GPU的渲染过程

#### 2.js动画

**js动画**

浏览器必须计算每一帧的状态；为了保证平滑的动画，我们必须在浏览器主线程计算新状态；把它们发送给GPU至少60次每秒。除了计算和发送数据比css动画要慢，主线程的负载也会影响动画； 当主线程的计算任务过多时，会造成动画的延迟、卡顿。
```
<style>
  #block{
  	position:absolute;
    left: 200px;
    top: 200px;
    width: 100px;
    height: 100px;
    background: #0c8;
    line-height: 100px;
    text-align: center;
  }
</style>
<div id="block">click me</div>
<script>
  var deg = 0;
  block.addEventListener('click', function(){
    var self = this;
  	requestAnimationFrame(function change(){
      self.style.transform = 'rotate(' + (deg++) +'deg)';
      requestAnimationFrame(change);
    });
  });
</script>
```
我们通过 定义速度 的方式来改变动画，这会导致我们很难精确控制动画时间和动画的幅度。像前面这种匀速运动其实还好，如果做一些复杂的变速运动，按照我们的定义方式，我们本该设置的元素属性值将会类似于求积分，然而时间又不连贯。

#### 3.css动画

**css动画的原理**

1.对于动画的每一帧，浏览器渲染需要主线程和绘制线程两个线程合作完成。
2.主线程会计算布局元素(耗时)，将位图绘入元素(耗时)
3.绘制线程则将位图加载到GPU内存(耗时)，GPU将各层合成，显示在屏幕上。这是其基本原理。
为了让动画流畅，我们需要减少回流和重绘的次数，最好是只发生composite合成。比如用opacity和tranform，这样可在动画开始前准备好所有需要的指令，并把它们发送给GPU。

**硬件加速的原理**

是指在计算机中透过把计算量非常大的工作分配给专门的硬件来处理来减轻CPU的工作量的技术。著作权归作者所有。浏览器接收到页面文档后，会将文档中的标记语言解析为DOM树。DOM树和CSS结合后形成浏览器构建页面的渲染树。渲染树中包含了大量的渲染元素，每一个渲染元素会被分到一个图层中，每个图层又会被加载到GPU形成渲染纹理，而图层在GPU中transform 是不会触发 repaint 的，最终这些使用 transform 的图层都会由独立的合成器进程进行处理。

**硬件加速GPU动画的问题**
1.每个复合层需要消耗额外的内存。如果GPU加载了大量的图层，那么很容易就会发生内容问题，这一点在移动端浏览器上尤为明显，所以，不要让页面的每个元素都使用硬件加速。
2.绘图层必须传输到GPU。取决于层的数量和传输可能会非常缓慢。这可能让一个元素在中低档设备上闪烁。

若代码如下，则2，3过程是循环操作，需要多次布局和重绘
因为每一帧的变化浏览器都在进行布局、绘制、把新的位图交给 GPU 内存(这恰好是我们上面提到的GPU的短板)

```
div {
    height: 100px;
    transition: height 1s linear;
}

div:hover {
    height: 200px;
}
```

优化，可以使用transform属性(硬件加速)：
1.transform 属性不会改变自己和他周围元素的布局，他会对元素的整体产生影响。
2.transform 动画由GPU控制，支持硬件加速。
3.因此，浏览器只需要一次生成这个元素的位图，然后动画开始时候交给 GPU 来处理他最擅长的位移、旋转、缩放等操作。这就解放了浏览器不再去做各种的布局、绘制等操作。

```
div {
    transform: scale(0.5);
    transition: transform 1s linear;
}

div:hover {
    transform: scale(1.0);
}
```

只发生合成，做动画的css需要满足三个条件，也就是触发硬件加速：
1.不影响文档流。
2.不依赖文档流。
3.不会造成重绘。
满足以上以上条件的css property只有transform和opacity。你可能以为position也满足以上条件，但事实不是这样，举个例子left属性可以使用百分比的值，依赖于它的offset parent。还有em、vh等其他单位也依赖于他们的环境。

总结：
首先transform和绝对定位都会产生新的图层，所以都不存在重排，图层在GPU中transform又不会引起重绘，这就是硬件加速的原理。另外，transform3D和2D的区别在于3D渲染前便会产生新的图层，而2D是在运行时产生图层，运行结束时删除图层。

#### 4.css和js动画对比

1.CSS动画只是改变transform和opacity，这时整个CSS动画得以在渲染线程完成，不会被大量js阻塞。JS动画则会在主线程执行，然后触发渲染线程进行下一步操作。这样css比js流畅

2.css动画兼容性不好，js兼容性典故对好些。

3.
