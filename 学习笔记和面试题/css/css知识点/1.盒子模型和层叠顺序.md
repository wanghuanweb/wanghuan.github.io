层叠样式表(英文全称：Cascading Style Sheets)

##### 1.介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？

1.1分类：IE盒子模型和标准W3C盒子模型

1.2盒子模型：content、padding、border、margin

1.3区别

W3C盒子模型中：元素的width=content的宽度

IE盒子模型中：元素的width=content+padding+border

**box-sizing--border-box 和 content-box**
box-sizing: content-box|border-box|inherit;

我个人认为W3C定义盒子模型与IE定义的盒子模型，IE定义的比较合理，元素的宽度应该包含border（边框）和padding（填充），这个和我们现实生活的盒子是一样的，W3C也认识到自己的问题了，所以在CSS3中新增了一个样式box-sizing，包含两个属性content-box 和 border-box。

（1） content-box  元素的width=content+padding+border
宽度和高度分别应用到元素的内容框。
在宽度和高度之外绘制元素的内边距和边框。
```
//元素宽度是250px
.test1{  
    box-sizing:content-box;  
    width:200px;  
    padding:10px;  
    border:15px solid #eee;  
}  
```
（2）border-box  
为元素设定的宽度和高度决定了元素的边框盒。
就是说，为元素指定的任何内边距和边框都将在已设定的宽度和高度内进行绘制。
通过从已设定的宽度和高度分别减去边框和内边距才能得到内容的宽度和高度。
```
//元素宽度就是200px
.test1{  
    box-sizing:border-box;  
    width:200px;  
    padding:10px;  
    border:15px solid #eee;  
}  
```

##### 2.层叠顺序（stacking level）和层叠上下文（stacking context）

 1.根据 z-index 的高低决定层叠的优先级

 2.但还要了解7阶层叠水平

 **著名的7阶层叠水平**

     1.形成堆叠上下文环境的元素的背景与边框
     2.拥有负 z-index 的子堆叠上下文元素 （负的越高越堆叠层级越低）
     3.正常流式布局，非 inline-block，无 position 定位（static除外）的子元素
     4.无 position 定位（static除外）的 float 浮动元素
     5.正常流式布局， inline-block元素，无 position 定位（static除外）的子元素（包括 display:table 和 display:inline ）
     6.拥有 z-index:0 的子堆叠上下文元素以及“positioned”且层叠级数为0的后代元素；
     7.拥有正 z-index: 的子堆叠上下文元素（正的越低越堆叠层级越低）

 规则有点多，但简单说，就是父元素会先绘制，接着是z-index为负值的子元素，然后是“non-positioned”元素，最后是按照层叠级数从0开始逐级绘制（这样说比较简单，省略了大量细节，因此并不是很准确）。如果层级相同，则按照元素在DOM树中的顺序来进行绘制。

 例子1：
 ```
 其中DIV#1和DIV#4是粉色框，position设置为absolute；
 DIV#2和DIV#3是粉色框，position设置为relative；
 DIV#5是黄色框，position为设置，默认static；
 <body>
 	<div id="absdiv1">DIV #1</div>
 	<div id="reldiv1">DIV #2</div>
 	<div id="reldiv2">DIV #3</div>
 	<div id="absdiv2">DIV #4</div>
 	<div id="normdiv">DIV #5</div>
 </body>
 ```
 层叠的效果div5肯定是在最下面。但是
 是浏览器在解析HTML的时候仍然是按照HTML文档流的顺序来解析的，实际的绘制顺序仍然是DIV#1->DIV#2->DIV#3->DIV#4->DIV#5。
 只不过，要绘DIV#5的时候，会对影响到的元素进行重新绘制，
 其渲染的效果看上去的顺序是DIV#5->DIV#1->DIV#2->DIV#3->DIV#4，将DIV#5提到了最前。

 例子2：---上面的比较是基于两个 div 都没有形成 堆叠上下文 这个为基础的
 ```
 <div class="container">
     <div class="inline-block">#divA display:inline-block</div>
     <div class="float"> #divB float:left</div>
 </div>

 .container{
     position:relative;
     background:#ddd;
 }
 .container > div{
     width:200px;
     height:200px;
 }
 .float{
     float:left;
     background-color:deeppink;
 }
 .inline-block{
     display:inline-block;
     background-color:yellowgreen;
     margin-left:-100px;
 }
 ```

 大概描述起来，意思就是拥有共同父容器的两个 DIV 重叠在一起，是 display:inline-block 叠在上面，还是float:left 叠在上面？

 注意这里 DOM 的顺序，是先生成 display:inline-block ，再生成 float:left 。当然也可以把两个的 DOM 顺序调转如下:

 ```
 <div class="container">
     <div class="float"> #divB float:left</div>
     <div class="inline-block">#divA display:inline-block</div>
 </div>
 ```

 会发现，无论顺序如何，始终是 display:inline-block 的 div 叠在上方。

 3.触发一个元素形成堆叠上下文的方法

 1.根元素 (HTML),
 2.z-index 值不为 “auto”的 绝对/相对定位，
 3.一个 z-index 值不为 “auto”的 flex 项目 (flex item)，即：父元素 display: flex|inline-flex，
 4.opacity 属性值小于 1 的元素（参考 the specification for opacity），
 5.transform 属性值不为 “none”的元素，
 6.mix-blend-mode 属性值不为 “normal”的元素，
 7.filter值不为“none”的元素，
 8.perspective值不为“none”的元素，
 9.isolation 属性被设置为 “isolate”的元素，
 10.position: fixed
 11.在 will-change 中指定了任意 CSS 属性，即便你没有直接指定这些属性的值
 12.-webkit-overflow-scrolling 属性被设置 “touch”的元素

 ```
 .container{
     position:relative;
     background:#ddd;
 }
 .container > div{
     width:200px;
     height:200px;
     opacity:0.9; // 注意这里，增加一个 opacity
 }
 .float{
     float:left;
     background-color:deeppink;
 }
 .inline-block{
     display:inline-block;
     background-color:yellowgreen;
     margin-left:-100px;
 }
 ```
 会看到，inline-block 的 div 不再一定叠在 float 的 div 之上，而是和 HTML 代码中 DOM 的堆放顺序有关，后添加的 div 会 叠在先添加的 div 之上。

 这里的关键点在于，添加的 opacity:0.9 这个让两个 div 都生成了 stacking context（堆叠上下文） 的概念。此时，要对两者进行层叠排列，就需要 z-index ，z-index 越高的层叠层级越高。
